# Использование Git в реальном мире
<!-- *...* -->

Основы Git очень просты, но стОит попасть в нестандартную ситуацию, и вы можете почувствовать себя совершенно запутавшимся. Ситуацию усугубляет тот факт, что при неверном решении вы рискуете потерять свои данные. На самом деле, с Git данные потерять очень трудно, но решение может быть спрятано в таком месте, куда сложно добраться, не обладая достаточными знаниями.

Вы получите свою долю злоключений с Git, но все проходят через это. Лучшее средство от проблем - это делать коммиты часто и вовремя. Чем они меньше и модульнее, тем меньше шансов появления трудноисправимой ошибки.

Многие спорят о том, как правильно использовать Git в работе. Мое мнение таково: ваш комментарий к коммиту должен полностью описывать (в настоящем времени) его содержимое, например "add About section to navbar on static pages". Если вы хотите использовать точку или "и", то, возможно, вы включили в коммит слишком много, и его следовало бы делать более модульным и независимым.

В процессе работы может появиться непреодолимое желание немедленно исправить увиденную ошибку в коде, изменив к примеру, CSS. Увы, все грешат этим. Лучшим же решением будет взять проблему на карандаш и закончить текущую работу. Затем, когда вы сделаете коммит, или проведете слияние, можете спокойно вернуться к решению увиденного бага, выделив его в отдельную ветку.

Повторюсь, Git создан для того, чтобы вы разделяли задачи, и коммиты были независимы друг от друга. С этим принципом вы можете с легкостью переключаться между задачами, а не смешивать их в одну кучу. Если вдруг вы вернетесь назад и измените ваш единственный цельный коммит, вы поймете суть проблемы на деле, и далее станете придерживаться правильной методики.

Касаемо Git... если вы не обладаете впечатляющей памятью, вы не изучите его.. вы просто должны работать с ним. Найдите проблему, исправьте ее, получите ошибку при слиянии... погуглите причину ошибки, изучите тактику при работе с Git в реальной работе.

Вернитесь к этому уроку, когда столкнетесь с проблемой. Для начала, мы посмотрим на нашем проекте пример работы с Git из реальной жизни. Раздел дополнительных ресурсов поможет вам найти качественные источники информации, когда они вам понадобятся.


## Порядок работы с Git в проектах с открытым кодом

Скажем, вы хотите внести свою лепту в этот сайт. Как это сделать? Описываемая методика - это полностью рабочий процесс, который уже используется сообществом сайта. Здесь мы подразумеваем, что вы не имеете прав на запись в оригинальный репозиторий.

Ключевыми игроками в этом случае являются `upstream` (оригинальный репозиторий на Github), `origin` (ваш форк этого репозитория) и ваш локальный клон форка ("local"). Представьте это как треугольник... за исключением того, что "local" только копирует данные с `upstream`, но не изменяет их, используя `push`.

### Первоначальная настройка

1. Используя кнопку "fork", сделайте форк репозитория "upstream" в ваш собственный аккаунт на Github.
2. Сделайте локальный клон форка, используя нечто вроде `$ git clone git@github.com:your_user_name_here/theodinproject.git` (полный url можно взять на правом сайдбаре странички вашего форка на Github).
3. Теперь у вас есть удаленный репозиторий, который указывает на `origin`, то есть на ваш форк. С помощью команды `push`, вы будете отправлять его изменения на Github. Вы также захотите иметь возможность использовать `pull` для оригинального репозитория на Github, который мы называем `upstream`, назначив его другим "удаленным". Чтобы сделать это, выполните `$ git remote add upstream git@github.com:TheOdinProject/theodinproject.git`.
4. Если вы используете git впервые, не забудьте указать ваше имя и почту, выполнив:

        $ git config --global user.name "YOUR NAME"
        $ git config --global user.email "YOUR_EMAIL@EXAMPLE.COM"

### Процесс работы

У нас есть две основные ветки -- `master` и `dev`. `master` используется для готового к работе в production кода. Любой код, попадающий сюда, будет протестирован и перейдет в production. Вы же будете работать с отдельной веткой и создавать пулл реквесты в ветку `dev`. Представьте, что ветки `master` вообще не существует.

5. Создайте ветку для любого функционала, используя `$ git checkout -b your_feature_name`.
6. Напишите код, закоммитьте его, напишите еще, повторите коммит (видите шаблон?).
7. Когда вы сделали работу, есть шанс, что кто-то уже внес изменения в "upstream". Это значит, что ветки `master` и `dev` уже устарели. Выполните `$ git fetch upstream` для получения свежих данных.
8. Используйте `$ git branch --all`, чтобы получить список всех веток, в том числе тех, которые обычно скрыты (например удаленных веток, которые вы только что получили). Среди них вы должны увидеть `upstream/master` и `upstream/dev`.
9. Теперь слейте изменения из upstream в локальную версию `dev`, используя `$ git merge`. В данном случае, будет необходимо выполнить `$ git checkout dev`, чтобы попасть на ветку `dev`, и затем выполнить `$ git merge upstream/dev`. На этом перенос изменений в `dev` будет закончен.
10. Замечу, что команды `$ git fetch upstream` и `$ git merge upstream/some_branch` - это то же самое, что и одна команда `$ git pull upstream/some_branch`, просто я предпочитаю разделять ее на два шага.
11. Теперь, когда ветка `dev` содержит актуальные данные, необходимо слить ее с вашей веткой нового функционала. Хотя это звучит странно, тем не менее это так и есть. Хотите вместо этого слить ветку нового функционала с `dev`? Да хотите, *но не сейчас*. **Ваша ветка с новым функционалом "грязная"**. Вы не знаете, содержит ли она потенциальные конфликты. Каждый раз, когда вы сливаетесь со "старшими" ветками (например ветку с вашим функционалом в `dev`, или же `dev` в `master`), вам необходимо, чтобы слияние было неконфликтным. Поэтому, сначала необходимо слить "старшую" ветку с "младшей" для разрешения конфликтов. Так что, мы выполняем `$ git checkout your_feature_name`, чтобы перейти на вашу ветку с новым функционалом, а затем `$ git merge dev`, чтобы слить в нее `dev`.
12. Возможно вы получите конфликт слияния... разрешите его с помощью `$ git mergetool`, или просто откройте вручную конфликтующие файлы. В основном, в таких случаях, в файлы вносятся маркеры, обозначающие, какие строки относятся к новому коду, а какие - к существующему. Необходимо один за одним отредактировать эти файлы (включая удаление маркированного текста), а затем пересохранить их. После этого, необходимо провести коммит, чтобы закончить слияние.


### Создание Pull Request (ПР)

13. После того, как ветка с вашим функционалом проверена, и вы знаете, что она сольется с `dev` без ошибок, осталось пройти пару шагов. Выполните слияние с `dev` командами `$ git checkout dev` и `$ git merge your_feature_name`.
14. Теперь необходимо отослать локальную ветку `dev` в `origin` (напомню, это ваш форк на Github). Вы не можете отослать изменения сразу на `upstream`, так как у вас нет туда доступа, поэтому вам необходимо выполнить Pull Request (ПР). Команда `$ git push origin dev` отправит ветку `dev` в `origin`.
15. И, наконец, создайте ПР, чтобы отправить свою версию `dev` в ветку `dev` репозитория `upstream`. Это может быть сделано с использованием пользовательского интерфейса Github. Здесь вы должны быть уверены в том, что отправляете ПР в ветку `dev`, а не в `master`.
16. Готово!


## Пункты для размышления

*Постарайтесь ответить на предложенные вопросы. После выполнения задания попробуйте ответить на них ещё раз*

* Как часто необходимо выполнять коммит?
* Как велики они должны быть?
* Что должен содержать комментарий?
* Можно ли коммитить незаконченный функционал?
* Какой метод работы вы должны использовать? (Merge? Topic Branches? Git-Flow? Rebase?)  Подсказка: здесь нет правильного ответа.

## Задания:

1. Прочтите [Best Practices](http://www.git-tower.com/learn/ebook/command-line/appendix/best-practices#start) от Тауэра.
2. Пробегитесь по [Git Best Practices](http://sethrobertson.github.io/GitBestPractices/) от Seth Robertson. Сильно не переживайте по поводу незнакомых команд... главное понять основные концепции.

## Дополнительные ресурсы

*Этот раздел содержит полезные ссылки на дополнительные материалы. Это не обязательно, так что расценивайте их как нечто полезное, если вы хотите поглубже погрузиться в тему*

* [Ветвление и метки в Git](http://programmers.stackexchange.com/questions/165725/git-branching-and-tagging-best-practices)
* [Git, лучшие практики по методам работы](http://www.lullabot.com/blog/article/git-best-practices-workflow-guidelines)
* [Официальный тренинг на Github](http://teach.github.com/)
* [Концептуальное понимание Git](http://www.sbf5.com/~cduan/technical/git/)
* Прочтите о ветвлении, используя [это интерактивное руководство](http://pcottle.github.io/learnGitBranching/).
* Этого недостаточно?  Посмотрите [этот список материалов для начинающих](http://sixrevisions.com/resources/git-tutorials-beginners/).
* Работу с разрешением конфликтов раскрывает также [это видео](https://www.youtube.com/watch?v=ieoHg0Vb-xo&list=PLxNY6twFc_xCxdSPLlxUS4C0VO3sni2DA), начиная приблизительно с 30-й минуты.
* Еще одно великолепное руководство - [Погружение в Git](http://gitimmersion.com/lab_01.html).
